# 7-2 分而治之

### 题目内容：

分而治之，各个击破是兵家常用的策略之一。在战争中，我们希望首先攻下敌方的部分城市，使其剩余的城市变成孤立无援，然后再分头各个击破。为此参谋部提供了若干打击方案。本题就请你编写程序，判断每个方案的可行性。

### 输入格式：

输入在第一行给出两个正整数 N 和 M（均不超过10 000），分别为敌方城市个数（于是默认城市从 1 到 N 编号）和连接两城市的通路条数。随后 M 行，每行给出一条通路所连接的两个城市的编号，其间以一个空格分隔。在城市信息之后给出参谋部的系列方案，即一个正整数 K （≤ 100）和随后的 K 行方案，每行按以下格式给出：

```
Np v[1] v[2] ... v[Np]
```

其中 `Np` 是该方案中计划攻下的城市数量，后面的系列 `v[i]` 是计划攻下的城市编号。

### 输出格式：

对每一套方案，如果可行就输出`YES`，否则输出`NO`。

### 输入样例：

```in
10 11
8 7
6 8
4 5
8 4
8 1
1 2
1 4
9 8
9 1
1 10
2 4
5
4 10 3 8 4
6 6 1 7 5 4 9
3 1 8 4
2 2 8
7 9 8 7 6 5 4 2
```

### 输出样例：

```out
NO
YES
YES
NO
NO
```

### 解题思路：

题目的意思是把所有的城市都分割开才能成功。在分割后，只需要判断还有没有边即可，如果最终没有边，则可行，否则不可行。

### 题解（代码较短，不用面向对象了）：

```c++
#include<bits/stdc++.h>
using namespace std;

int main() {
	int N, M;
	cin >> N >> M;
	int a[10010], b[10010], tmp[10010];	//a是始点，b是终点，tmp用来判断是否被删除
	for (int i = 1; i <= M; i++) 
		cin >> a[i] >> b[i];
	int K;
	cin >> K;
	int Np, x, flag;
	while (K--) {
		//初始化tmp置零,0表示未被删除
		for (int i = 0; i < 10010; i++)
            tmp[i] = 0; //sizeof不能用，会出现段错误
		flag = 1;
		cin >> Np;//该方案中计划攻下的城池数量
		for (int i = 1; i <= Np; i++) {
			cin >> x;//计划攻下的城池
			tmp[x] = -1;//tmp为-1，代表这个点被删除
		}
		for (int i = 1; i <= M; i++) {
			if (tmp[a[i]] == 0 && tmp[b[i]] == 0) {	
                //tmp为0代表这个点没有被删除，若始点和终点都没被删除说明这条路还在
				flag = 0;
				break;
			}
		}
		if (flag)
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
	}
}

```

